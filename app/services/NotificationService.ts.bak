import AsyncStorage from '@react-native-async-storage/async-storage';
import * as Device from 'expo-device';
import * as Notifications from 'expo-notifications';
import { Platform } from 'react-native';

// Configure how notifications appear when the app is in the foreground
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowAlert: true,
    shouldPlaySound: true,
    shouldSetBadge: false,
    shouldShowBanner: true,
    shouldShowList: true
  }),
});

// Type definitions
type Task = {
  id: string;
  title: string;
  dueDate: string;
  description?: string;
  subject?: string;
  completed?: boolean;
};

type Exam = {
  id: string;
  title: string;
  date: string;
  time?: string;
  description?: string;
  subject?: string;
  completed?: boolean;
};

// Notification types
export const NOTIFICATION_TYPES = {
  TASK_DUE: 'TASK_DUE',
  EXAM_REMINDER: 'EXAM_REMINDER',
  TIMER_COMPLETED: 'TIMER_COMPLETED',
  DAILY_GOAL: 'DAILY_GOAL',
  STREAK_REMINDER: 'STREAK_REMINDER',
  ACHIEVEMENT_UNLOCKED: 'ACHIEVEMENT_UNLOCKED',
};

// Request permission for notifications
export const requestNotificationPermissions = async () => {
  const { status: existingStatus } = await Notifications.getPermissionsAsync();

  let finalStatus = existingStatus;
  if (existingStatus !== 'granted') {
    const { status } = await Notifications.requestPermissionsAsync();
    finalStatus = status;
  }

  if (finalStatus !== 'granted') {
    return false;
  }

  if (Platform.OS === 'android') {
    await Notifications.setNotificationChannelAsync('default', {
      name: 'Default',
      importance: Notifications.AndroidImportance.MAX,
      vibrationPattern: [0, 250, 250, 250],
      lightColor: '#FF231F7C',
    });

    // Create additional channels for different notification types
    await Notifications.setNotificationChannelAsync('tasks', {
      name: 'Tasks',
      description: 'Notifications for task due dates',
      importance: Notifications.AndroidImportance.HIGH,
      vibrationPattern: [0, 250, 250, 250],
      lightColor: '#FF231F7C',
    });

    await Notifications.setNotificationChannelAsync('exams', {
      name: 'Exams',
      description: 'Notifications for exam reminders',
      importance: Notifications.AndroidImportance.HIGH,
      vibrationPattern: [0, 250, 250, 250],
      lightColor: '#FF231F7C',
    });

    await Notifications.setNotificationChannelAsync('timer', {
      name: 'Timer',
      description: 'Notifications for timer sessions',
      importance: Notifications.AndroidImportance.DEFAULT,
      vibrationPattern: [0, 250, 250, 250],
      lightColor: '#FF231F7C',
    });

    await Notifications.setNotificationChannelAsync('streaks', {
      name: 'Streaks',
      description: 'Notifications for streak maintenance',
      importance: Notifications.AndroidImportance.DEFAULT,
      vibrationPattern: [0, 250, 250, 250],
      lightColor: '#FF231F7C',
    });

    await Notifications.setNotificationChannelAsync('achievements', {
      name: 'Achievements',
      description: 'Notifications for achievement unlocks',
      importance: Notifications.AndroidImportance.LOW,
      vibrationPattern: [0, 250, 250, 250],
      lightColor: '#FF231F7C',
    });
  }

  return true;
};

// Schedule a task due notification
export const scheduleTaskDueNotification = async (task: Task) => {
  if (!task.dueDate) return null;

  // Check if task notifications are enabled
  if (!(await isNotificationTypeEnabled(NOTIFICATION_TYPES.TASK_DUE))) {
    return null;
  }

  // Calculate notification time (default to 1 day before due date)
  const dueDate = new Date(task.dueDate);
  const notifyDate = new Date(dueDate);
  notifyDate.setDate(notifyDate.getDate() - 1); // 1 day before

  // Make sure notification time is in the future
  if (notifyDate <= new Date()) {
    notifyDate.setHours(new Date().getHours());
    notifyDate.setMinutes(new Date().getMinutes() + 5); // 5 minutes from now if due date is very close
  }

  // Check if this notification is already scheduled
  const storedNotification = await AsyncStorage.getItem(`taskNotification:${task.id}`);
  if (storedNotification) {
    const notificationId = JSON.parse(storedNotification).id;
    await Notifications.cancelScheduledNotificationAsync(notificationId);
  }

  const notificationId = await Notifications.scheduleNotificationAsync({
    content: {
      title: 'Task Due Tomorrow',
      body: `"${task.title}" is due tomorrow.`,
      data: { type: NOTIFICATION_TYPES.TASK_DUE, taskId: task.id },
    },
    trigger: notifyDate,
  });

  // Store notification ID for future reference
  await AsyncStorage.setItem(`taskNotification:${task.id}`, JSON.stringify({
    id: notificationId,
    scheduledFor: notifyDate.toISOString(),
  }));

  return notificationId;
};

// Cancel a task notification
export const cancelTaskNotification = async (taskId: string) => {
  const storedNotification = await AsyncStorage.getItem(`taskNotification:${taskId}`);
  if (storedNotification) {
    const notificationId = JSON.parse(storedNotification).id;
    await Notifications.cancelScheduledNotificationAsync(notificationId);
    await AsyncStorage.removeItem(`taskNotification:${taskId}`);
  }
};

// Schedule an exam reminder notification
export const scheduleExamReminder = async (exam: Exam) => {
  if (!exam.date) return null;

  // Calculate notification times (1 day before and 1 hour before)
  const examDate = new Date(`${exam.date}${exam.time ? `T${exam.time}` : 'T00:00:00'}`);

  // 1 day before
  const dayBeforeDate = new Date(examDate);
  dayBeforeDate.setDate(dayBeforeDate.getDate() - 1);

  // 1 hour before
  const hourBeforeDate = new Date(examDate);
  hourBeforeDate.setHours(hourBeforeDate.getHours() - 1);

  const notificationIds = [];

  // Check if future dates
  if (dayBeforeDate > new Date()) {
    const dayBeforeId = await Notifications.scheduleNotificationAsync({
      content: {
        title: 'Exam Tomorrow',
        body: `Your "${exam.title}" exam is scheduled for tomorrow.`,
        data: { type: NOTIFICATION_TYPES.EXAM_REMINDER, examId: exam.id },
      },
      trigger: {
        type: 'date',
        date: dayBeforeDate,
      },
    });
    notificationIds.push({ id: dayBeforeId, type: 'dayBefore' });
  }

  if (hourBeforeDate > new Date()) {
    const hourBeforeId = await Notifications.scheduleNotificationAsync({
      content: {
        title: 'Exam Soon',
        body: `Your "${exam.title}" exam is in 1 hour.`,
        data: { type: NOTIFICATION_TYPES.EXAM_REMINDER, examId: exam.id },
      },
      trigger: hourBeforeDate,
    });
    notificationIds.push({ id: hourBeforeId, type: 'hourBefore' });
  }

  if (notificationIds.length > 0) {
    await AsyncStorage.setItem(`examNotification:${exam.id}`, JSON.stringify(notificationIds));
  }

  return notificationIds;
};

// Cancel exam notifications
export const cancelExamReminders = async (examId: string) => {
  const storedNotifications = await AsyncStorage.getItem(`examNotification:${examId}`);
  if (storedNotifications) {
    const notifications = JSON.parse(storedNotifications);
    for (const notification of notifications) {
      await Notifications.cancelScheduledNotificationAsync(notification.id);
    }
    await AsyncStorage.removeItem(`examNotification:${examId}`);
  }
};

// Send immediate timer completion notification
export const sendTimerCompletionNotification = async (sessionType: string, subject?: string) => {
  let title = 'Session Complete';
  let body = 'Your study session is complete.';

  if (sessionType === 'pomodoro') {
    body = 'Time for a break!';
  } else if (sessionType === 'break') {
    title = 'Break Complete';
    body = 'Ready to get back to work?';
  }

  if (subject) {
    body += ` (${subject})`;
  }

  await Notifications.scheduleNotificationAsync({
    content: {
      title,
      body,
      data: { type: NOTIFICATION_TYPES.TIMER_COMPLETED },
    },
    trigger: null, // null trigger means send immediately
  });
};

// Schedule a streak reminder if user hasn't studied today
export const scheduleStreakReminder = async (currentStreak: number) => {
  // Cancel any existing streak reminders
  const existingReminder = await AsyncStorage.getItem('streakReminder');
  if (existingReminder) {
    const notificationId = JSON.parse(existingReminder).id;
    await Notifications.cancelScheduledNotificationAsync(notificationId);
  }

  // Schedule for 8PM if it's before 8PM, otherwise don't schedule
  const reminderTime = new Date();
  reminderTime.setHours(20, 0, 0, 0); // 8:00 PM

  if (new Date() >= reminderTime) {
    return null; // Don't schedule if it's already past 8PM
  }

  const notificationId = await Notifications.scheduleNotificationAsync({
    content: {
      title: 'Maintain Your Streak!',
      body: `Don't break your ${currentStreak}-day streak. Study today to keep it going!`,
      data: { type: NOTIFICATION_TYPES.STREAK_REMINDER },
    },
    trigger: {
      date: reminderTime,
    },
  });

  await AsyncStorage.setItem('streakReminder', JSON.stringify({
    id: notificationId,
    scheduledFor: reminderTime.toISOString(),
  }));

  return notificationId;
};

// Schedule a daily goal reminder if user is behind
export const scheduleDailyGoalReminder = async (
  currentMinutes: number,
  goalMinutes: number
) => {
  // If already reached the goal, no need to remind
  if (currentMinutes >= goalMinutes) return null;

  // Cancel any existing goal reminders
  const existingReminder = await AsyncStorage.getItem('goalReminder');
  if (existingReminder) {
    const notificationId = JSON.parse(existingReminder).id;
    await Notifications.cancelScheduledNotificationAsync(notificationId);
  }

  // Schedule for 6PM
  const reminderTime = new Date();
  reminderTime.setHours(18, 0, 0, 0); // 6:00 PM

  if (new Date() >= reminderTime) {
    return null; // Don't schedule if it's already past 6PM
  }

  const minutesLeft = goalMinutes - currentMinutes;

  const notificationId = await Notifications.scheduleNotificationAsync({
    content: {
      title: 'Daily Goal Progress',
      body: `You still need ${minutesLeft} more minutes to reach your daily study goal.`,
      data: { type: NOTIFICATION_TYPES.DAILY_GOAL },
    },
    trigger: {
      date: reminderTime,
    },
  });

  await AsyncStorage.setItem('goalReminder', JSON.stringify({
    id: notificationId,
    scheduledFor: reminderTime.toISOString(),
  }));

  return notificationId;
};

// Send achievement notification
export const sendAchievementNotification = async (achievementName: string) => {
  await Notifications.scheduleNotificationAsync({
    content: {
      title: 'Achievement Unlocked! ðŸ†',
      body: `You've unlocked the "${achievementName}" achievement!`,
      data: { type: NOTIFICATION_TYPES.ACHIEVEMENT_UNLOCKED, achievement: achievementName },
    },
    trigger: null, // null trigger means send immediately
  });
};

// Cancel all notifications
export const cancelAllNotifications = async () => {
  await Notifications.cancelAllScheduledNotificationsAsync();

  // Clear all stored notification IDs
  const keys = await AsyncStorage.getAllKeys();
  const notificationKeys = keys.filter(key =>
    key.startsWith('taskNotification:') ||
    key.startsWith('examNotification:') ||
    key === 'streakReminder' ||
    key === 'goalReminder'
  );

  if (notificationKeys.length > 0) {
    await AsyncStorage.multiRemove(notificationKeys);
  }
};

// Reschedule all task notifications
export const rescheduleAllTaskNotifications = async (tasks: Task[]) => {
  // First cancel all existing task notifications
  const keys = await AsyncStorage.getAllKeys();
  const taskNotificationKeys = keys.filter(key => key.startsWith('taskNotification:'));

  for (const key of taskNotificationKeys) {
    const taskId = key.replace('taskNotification:', '');
    await cancelTaskNotification(taskId);
  }

  // Schedule new notifications for all incomplete tasks with due dates
  const incompleteTasks = tasks.filter(task => !task.completed && task.dueDate);
  for (const task of incompleteTasks) {
    await scheduleTaskDueNotification(task);
  }
};

// Reschedule all exam notifications
export const rescheduleAllExamNotifications = async (exams: Exam[]) => {
  // First cancel all existing exam notifications
  const keys = await AsyncStorage.getAllKeys();
  const examNotificationKeys = keys.filter(key => key.startsWith('examNotification:'));

  for (const key of examNotificationKeys) {
    const examId = key.replace('examNotification:', '');
    await cancelExamReminders(examId);
  }

  // Schedule new notifications for all upcoming exams
  const upcomingExams = exams.filter(exam => !exam.completed && new Date(exam.date) > new Date());
  for (const exam of upcomingExams) {
    await scheduleExamReminder(exam);
  }
};

// Check if specific notification type is enabled
export const isNotificationTypeEnabled = async (type: string) => {
  try {
    const settings = await AsyncStorage.getItem('notification_settings');
    if (!settings) return true; // Default to enabled if no settings

    const parsedSettings = JSON.parse(settings);

    switch (type) {
      case NOTIFICATION_TYPES.TASK_DUE:
        return parsedSettings.tasksDue !== false;
      case NOTIFICATION_TYPES.EXAM_REMINDER:
        return parsedSettings.exams !== false;
      case NOTIFICATION_TYPES.TIMER_COMPLETED:
        return parsedSettings.timerCompleted !== false;
      case NOTIFICATION_TYPES.STREAK_REMINDER:
        return parsedSettings.streakReminders !== false;
      case NOTIFICATION_TYPES.DAILY_GOAL:
        return parsedSettings.dailyGoals !== false;
      case NOTIFICATION_TYPES.ACHIEVEMENT_UNLOCKED:
        return parsedSettings.achievements !== false;
      default:
        return true;
    }
  } catch (error) {
    console.error('Error checking notification type settings:', error);
    return true; // Default to enabled on error
  }
}

// Initialize notifications system
export const initializeNotifications = async (
  notificationsEnabled: boolean,
  tasks: Task[],
  exams: Exam[],
  streak: { current: number },
  dailyStudyMinutes: number,
  dailyGoalMinutes: number
) => {
  if (!notificationsEnabled) {
    await cancelAllNotifications();
    return;
  }

  const permissionGranted = await requestNotificationPermissions();
  if (!permissionGranted) return;

  // Schedule all task notifications
  await rescheduleAllTaskNotifications(tasks);

  // Schedule all exam notifications
  await rescheduleAllExamNotifications(exams);

  // Schedule streak reminder if there's an active streak
  if (streak.current > 0) {
    await scheduleStreakReminder(streak.current);
  }

  // Schedule daily goal reminder if behind on goal
  if (dailyStudyMinutes < dailyGoalMinutes) {
    await scheduleDailyGoalReminder(dailyStudyMinutes, dailyGoalMinutes);
  }
};
