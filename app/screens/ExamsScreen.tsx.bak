import { Ionicons } from '@expo/vector-icons';
import DateTimePicker from '@react-native-community/datetimepicker';
import { differenceInDays, format, isPast } from 'date-fns';
import { useContext, useState, useEffect } from 'react';
import { Alert, FlatList, Modal, ScrollView, StyleSheet, Text, TextInput, Touchabl          <TouchableOpacity
            style={styles.examAction}
            onPress={() => confirmDeleteExam(item.id)}
          >
            <Ionicons name="trash-outline" size={20} color={theme.danger} />
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    );
  };ty, View } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { AppContext } from '../context/AppContext';
import { useTheme } from '../context/ThemeContext';
import * as NotificationService from '../services/NotificationService';

// Define types
interface Exam {
  id: string;
  title: string;
  description: string;
  subject: string;
  date: string;
  time: string;
  location: string;
  completed: boolean;
  createdAt?: string;
}

const ExamsScreen = () => {
  const { theme } = useTheme();
  const { exams, subjects, addExam, updateExam, deleteExam, settings } = useContext(AppContext);
  const [notificationsEnabled, setNotificationsEnabled] = useState(false);

  // Check if notifications are enabled
  useEffect(() => {
    const checkNotificationStatus = async () => {
      const { status } = await NotificationService.checkPermissions();
      setNotificationsEnabled(status === 'granted' && settings.notifications);
    };

    checkNotificationStatus();
  }, [settings.notifications]);

  const [modalVisible, setModalVisible] = useState(false);
  const [showDatePicker, setShowDatePicker] = useState(false);
  const [newExam, setNewExam] = useState({
    title: '',
    description: '',
    subject: '',
    date: new Date(),
    time: '09:00',
    location: '',
    completed: false,
  });

  // Sort exams by date (upcoming first, then past)
  const sortedExams = [...exams].sort((a, b) => {
    const dateA = new Date(a.date);
    const dateB = new Date(b.date);

    // If one is past and one is upcoming, upcoming comes first
    if (isPast(dateA) && !isPast(dateB)) return 1;
    if (!isPast(dateA) && isPast(dateB)) return -1;

    // Otherwise sort by date
    return dateA - dateB;
  });

  // Group exams by upcoming/past
  const upcomingExams = sortedExams.filter(exam => !isPast(new Date(exam.date)));
  const pastExams = sortedExams.filter(exam => isPast(new Date(exam.date)));

  // Handle date change
  const onDateChange = (event, selectedDate) => {
    const currentDate = selectedDate || newExam.date;
    setShowDatePicker(false);
    setNewExam({ ...newExam, date: currentDate });
  };

  // Format date for display
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return format(date, 'EEEE, MMMM d, yyyy');
  };

  // Calculate days until exam
  const getDaysUntil = (dateString) => {
    const date = new Date(dateString);
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const days = differenceInDays(date, today);

    if (days < 0) {
      return 'Past';
    } else if (days === 0) {
      return 'Today';
    } else if (days === 1) {
      return 'Tomorrow';
    } else {
      return `${days} days`;
    }
  };

  // Save new exam with notification
  const saveExam = async () => {
    if (!newExam.title) {
      Alert.alert('Please enter a title for the exam.');
      return;
    }

    // Save the exam
    if (newExam.id) {
      // Update existing exam
      updateExam(newExam.id, newExam);

      // Handle notification for updated exam if notifications are enabled
      if (notificationsEnabled && !newExam.completed) {
        // First cancel any existing notifications for this exam
        await NotificationService.cancelExamReminders(newExam.id);

        // Then schedule new notifications if the exam is in the future
        if (!isPast(new Date(newExam.date))) {
          await NotificationService.scheduleExamReminder(newExam);
        }
      } else if (newExam.completed) {
        // If exam is marked as completed, cancel any notifications
        await NotificationService.cancelExamReminders(newExam.id);
      }
    } else {
      // Create new exam
      const createdExam = addExam(newExam);

      // Schedule notification for new exam if enabled and in the future
      if (notificationsEnabled && !newExam.completed && !isPast(new Date(newExam.date))) {
        // The addExam function should return the created exam with an ID
        if (createdExam && createdExam.id) {
          await NotificationService.scheduleExamReminder(createdExam);
        }
      }
    }

    setModalVisible(false);
    setNewExam({
      title: '',
      description: '',
      subject: '',
      date: new Date(),
      time: '09:00',
      location: '',
      completed: false,
    });
  };

  // Delete an exam and cancel its notifications
  const confirmDeleteExam = (id) => {
    Alert.alert(
      'Delete Exam',
      'Are you sure you want to delete this exam?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            // Cancel any notifications for this exam
            await NotificationService.cancelExamReminders(id);
            // Delete the exam
            deleteExam(id);
          },
        },
      ]
    );
  };

  // Toggle exam completion and handle notifications
  const toggleExamCompletion = async (id) => {
    const exam = exams.find(e => e.id === id);
    if (exam) {
      const updatedExam = { ...exam, completed: !exam.completed };
      updateExam(id, updatedExam);

      // If exam is marked as completed, cancel notifications
      if (!exam.completed) {
        await NotificationService.cancelExamReminders(id);
      } else {
        // If exam is marked as incomplete and is in the future, reschedule notification
        if (notificationsEnabled && !isPast(new Date(exam.date))) {
          await NotificationService.scheduleExamReminder({ ...exam, completed: false });
        }
      }
    }
  };

  // Request notification permissions if needed
  const ensureNotificationPermission = async () => {
    if (!notificationsEnabled && settings.notifications) {
      const { status } = await NotificationService.requestPermissionsAsync();
      setNotificationsEnabled(status === 'granted');
      return status === 'granted';
    }
    return notificationsEnabled;
  };

  // Updated openAddExamModal function
  const openAddExamModal = async () => {
    // If notifications are enabled in settings but permission is not granted,
    // try to request permission when adding an exam
    if (settings.notifications && !notificationsEnabled) {
      await ensureNotificationPermission();
    }

    setNewExam({
      title: '',
      description: '',
      subject: '',
      date: new Date(),
      time: '09:00',
      location: '',
      completed: false,
    });
    setModalVisible(true);
  };

  // Render an exam item
  const renderExamItem = ({ item }) => {
    const subjectColor = subjects.find(s => s.name === item.subject)?.color || '#607D8B';
    const daysUntil = getDaysUntil(item.date);
    const isPastExam = isPast(new Date(item.date));

    return (
      <TouchableOpacity
        style={[
          styles.examItem,
          { backgroundColor: theme.card },
          item.completed && { backgroundColor: theme.isDark ? theme.card : '#F8F9FA' }
        ]}
        onPress={() => {
          setNewExam(item);
          setModalVisible(true);
        }}
      >
        <View style={styles.examHeader}>
          <View style={styles.examTitleContainer}>
            <Text
              style={[
                styles.examTitle,
                { color: theme.text },
                item.completed && { color: theme.textSecondary, textDecorationLine: 'line-through' }
              ]}
            >
              {item.title}
            </Text>
            {item.subject && (
              <View style={[styles.subjectTag, { backgroundColor: `${subjectColor}20` }]}>
                <Text style={[styles.subjectText, { color: subjectColor }]}>
                  {item.subject}
                </Text>
              </View>
            )}
          </View>

          <TouchableOpacity
            style={[
              styles.statusButton,
              item.completed ?
                { backgroundColor: `${theme.success}20` } :
                isPastExam ?
                  { backgroundColor: `${theme.danger}20` } :
                  { backgroundColor: `${theme.primary}20` }
            ]}
            onPress={() => toggleExamCompletion(item.id)}
          >
            <Text style={[
              styles.statusButtonText,
              {
                color: item.completed ? theme.success :
                  isPastExam ? theme.danger :
                    theme.primary
              }
            ]}>
              {item.completed ? 'Completed' : isPastExam ? 'Past' : daysUntil}
            </Text>
          </TouchableOpacity>
        </View>

        <View style={styles.examDetails}>
          <View style={styles.examDetail}>
            <Ionicons name="calendar-outline" size={16} color={theme.textSecondary} />
            <Text style={[styles.examDetailText, { color: theme.textSecondary }]}>{formatDate(item.date)}</Text>
          </View>

          {item.time && (
            <View style={styles.examDetail}>
              <Ionicons name="time-outline" size={16} color={theme.textSecondary} />
              <Text style={[styles.examDetailText, { color: theme.textSecondary }]}>{item.time}</Text>
            </View>
          )}

          {item.location && (
            <View style={styles.examDetail}>
              <Ionicons name="location-outline" size={16} color={theme.textSecondary} />
              <Text style={[styles.examDetailText, { color: theme.textSecondary }]}>{item.location}</Text>
            </View>
          )}
        </View>

        <View style={styles.examActions}>
          <TouchableOpacity
            style={styles.examAction}
            onPress={() => {
              setNewExam(item);
              setModalVisible(true);
            }}
          >
            <Ionicons name="create-outline" size={20} color={theme.primary} />
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.examAction}
            onPress={() => confirmDeleteExam(item.id)}
          >
            <Ionicons name="trash-outline" size={20} color={theme.danger} />
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    );
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: theme.background }}>
      <View style={{ flex: 1, padding: 16 }}>
        <TouchableOpacity
          style={[styles.addButton, { backgroundColor: theme.primary }]}
          onPress={openAddExamModal}
        >
          <Ionicons name="add" size={24} color="#FFFFFF" />
          <Text style={styles.addButtonText}>Add Exam</Text>
        </TouchableOpacity>

        {exams.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Ionicons name="calendar-outline" size={64} color={theme.textSecondary} />
            <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
              No exams yet. Tap the button above to add one.
            </Text>
          </View>
        ) : (
          <FlatList
            data={sortedExams}
            renderItem={renderExamItem}
            keyExtractor={item => item.id}
            contentContainerStyle={styles.listContainer}
          />
        )}
      </View>
    </SafeAreaView>
  );
};
        </View>
      </TouchableOpacity>
    );
  };

  // Render the screen content
  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: theme.background }}>
      <View style={{ flex: 1, padding: 16 }}>
        <TouchableOpacity
          style={[styles.addButton, { backgroundColor: theme.primary }]}
          onPress={openAddExamModal}
        >
          <Ionicons name="add" size={24} color="#FFFFFF" />
          <Text style={styles.addButtonText}>Add Exam</Text>
        </TouchableOpacity>

        {/* Exams List */}
        {exams.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Ionicons name="calendar-outline" size={64} color={theme.textSecondary} />
            <Text style={[styles.emptyText, { color: theme.textSecondary }]}>
              No exams yet. Tap the button above to add one.
            </Text>
          </View>
        ) : (
          <FlatList
            data={sortedExams}
            renderItem={renderExamItem}
            keyExtractor={item => item.id}
            contentContainerStyle={styles.listContainer}
          />
        )}
      </View>

      {/* Add/Edit Exam Modal */}
      {/* Modal content would go here */}

      {/* Styles */}
      <StyleSheet.create({
        // Your styles would go here
      });
    </SafeAreaView>
  );
};

export default ExamsScreen;
